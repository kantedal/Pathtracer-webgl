<!DOCTYPE HTML>
<html>
	<head>
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
		<title>WebGL Boilerplate</title>

		<style>
			html, body {
				background-color: #fff;
				margin: 0px;
				overflow: hidden;
				width: 100%;
				height: 100%;
			}
			canvas {
				width: 512px;
				height: 512px;
			}
		</style>
	</head>
	<body>
    <!-- <script src="./dist/glMatrix-0.9.5.min.js"> </script> -->
		<script src="./lib/gl-matrix-min.js"></script>
		<script src="./lib/jquery.min.js"></script>
    <script src="./dist/app.js"> </script>

		<canvas></canvas>
		<div id="info"></div>

		<script id="vs" type="x-shader/vertex">
			attribute vec3 position;

			void main() {
				gl_Position = vec4( position, 1.0 );
			}
		</script>

		<script id="fs" type="x-shader/fragment">
			uniform float time;
			uniform vec2 resolution;

			uniform sampler2D u_image0;
			uniform sampler2D u_image1;

			float random(vec3 scale, float seed) {
				return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);
			}

			struct Camera {
				vec3 position;
				vec3 v1;
				vec3 v2;
				vec3 v3;
				vec3 v4;
			};
			Camera camera;

			struct Ray {
				vec3 start_position;
				vec3 direction;
			};

			struct Collision {
				vec3 position;
				vec3 normal;
				int material_index;
			};

			struct Material {
				vec3 color;
				int material_type;
				float emission_rate;
			};
			Material materials[6];

			Material GetMaterial(int material_index) {
				for (int i = 0; i < 6; i++) {
					if (i == material_index) {
						return materials[i];
					}
				}
			}

			vec3 BRDF(Ray ray, Material material, vec3 collision_normal) {
				// Diffuse material
				if (material.material_type == 0) {
					return material.color * dot(ray.direction, -collision_normal) / 3.14 * 2.0;
				}

				// Specular material
				if (material.material_type == 1) {
					return material.color;
				}

				// Emission material
				if (material.material_type == 2) {
					return material.color;
				}

				// Transmission material
				if (material.material_type == 3) {
					return material.color;
				}
			}

			vec3 PDF(Ray ray, Material material, vec3 collision_normal) {
				float r1 = 2.0 * 3.14 * random(vec3(12.9898, 78.233, 151.7182), time);
        float r2 = random(vec3(63.7264, 10.873, 623.6736), time);
        float r2s = sqrt(r2);

        vec3 w = collision_normal;
        vec3 u = normalize(cross((abs(w.x) > .1 ? vec3(0, 1, 0) : vec3(1, 0, 0)), w));
        vec3 v = cross(w, u);

        // compute cosine weighted random ray direction on hemisphere
        vec3 next_dir = normalize(u * cos(r1) * r2s + v * sin(r1) * r2s + w * sqrt(1.0 - r2));

				return next_dir;
			}


			Camera InitCamera() {
				float field_of_view = 3.14 / 4.0;
        float d = 0.5 / tan(field_of_view / 2.0);
      	vec3 camera_v1 = vec3(0, -1.0/d, -1.0/d);
        vec3 camera_v2 = vec3(0, 1.0/d, -1.0/d);
        vec3 camera_v3 = vec3(0, 1.0/d, 1.0/d);
        vec3 camera_v4 = vec3(0, -1.0/d, 1.0/d);
				vec3 position = vec3(-1,0,0);

				Camera c = Camera(position, camera_v1, camera_v2, camera_v3, camera_v4);
				return c;
			}

			struct Sphere {
				vec3 position;
				float radius;
				int material_index;
			};
			Sphere spheres[2];

			bool SphereIntersection(Ray ray, Sphere sphere, inout Collision collision) {
				vec3 position = sphere.position;
				float radius = sphere.radius;

				vec3 op = position - ray.start_position;
				float t, epsilon = 0.0001;
				float b = dot(op, ray.direction);
				float disc = b * b - dot(op, op) + radius * radius;
				if (disc < 0.0) return false;
				else disc = sqrt(disc);


			  t = (t = b - disc) > epsilon ? t : ((t = b + disc) > epsilon ? t : 0.0);

				if (t < 0.01)
				  return false;

				collision.position = ray.start_position + ray.direction * t;
				collision.normal = normalize(collision.position  - position);
				collision.material_index = sphere.material_index;

				return true;
			}

			struct Triangle {
				vec3 v0;
				vec3 edge1;
				vec3 edge2;
				int material_index;
			};

			Ray CreateRay(vec2 pixel_position) {
				vec3 base_vector_x = camera.v3 - camera.v4;
				vec3 base_vector_y = camera.v1 - camera.v4;

				float width = 512.0;
				float height = 512.0;

				vec3 dx = (base_vector_x / width);
				vec3 dy = (base_vector_y / height);

		    vec3 vert = camera.v4 + pixel_position.x / width * base_vector_x + (1.0 - pixel_position.y / height) * base_vector_y;
		    vec3 direction = normalize(vert - camera.position);

				return Ray(camera.position, direction);
			}

			Triangle GetTriangleFromIndex(int triangle_index) {
				// Fetch triangle from texture
				vec2 sample = vec2(1.0,0) / vec2(2048, 2048);
				vec2 start_sample = (vec2(1.0,0) / vec2(2048, 2048)) * float(triangle_index) * 4.0 + 0.5 * sample;

				vec3 v0 = vec3(texture2D(u_image0, start_sample));
				vec3 v1 = vec3(texture2D(u_image0, start_sample + sample));
				vec3 v2 = vec3(texture2D(u_image0, start_sample + 2.0 * sample));

				vec3 edge1 = v1 - v0;
				vec3 edge2 = v2 - v0;

				int material_index = int(texture2D(u_image0, start_sample + 3.0 * sample).x);

				return Triangle(v0, edge1, edge2, material_index);
			}


			bool TriangleIntersection(Ray ray, Triangle triangle, inout Collision collision) {
				float EPS = 0.0001;

				//Begin calculating determinant - also used to calculate u parameter
				vec3 P = cross(ray.direction, triangle.edge2);
				float det = dot(triangle.edge1, P);

				if (det > -EPS && det < EPS) return false;
				float inv_det = 1.0 / det;

				//Distance from vertex1 to ray origin
				vec3 T = ray.start_position - triangle.v0;
				float u = dot(T, P);
				if (u < 0.0 || u > det) return false;

				vec3 Q = cross(T, triangle.edge1);

				float v = dot(ray.direction, Q);
				if(v < 0.0 || u+v > det) return false;

				float t = dot(triangle.edge2, Q);

				if(t > EPS) {
				    collision.position = ray.start_position + inv_det * t * ray.direction;
				    collision.material_index = triangle.material_index;
				    collision.normal = normalize(cross(triangle.edge1, triangle.edge2));
				    return true;
				}

				return false;
			}

			bool SceneIntersections(Ray ray, inout Collision collision) {
				//Collision collision = Collision(vec3(0,0,0), vec3(0,0,0), 0);

				//Check sphere collision
				for (int sphere_idx = 0; sphere_idx < 2; sphere_idx++) {
					Sphere sphere = spheres[sphere_idx];
					if (SphereIntersection(ray, sphere, collision)) {
						return true;
					}
				}

				// Check triangle collision
				for (int tri_idx = 0; tri_idx < 25; tri_idx++) {
					Triangle triangle = GetTriangleFromIndex(tri_idx);
					if (TriangleIntersection(ray, triangle, collision)) {
						return true;
					}
				}

				// Triangle triangle = GetTriangleFromIndex(0);
				return false;
			}

			vec3 TraceRay(Ray ray) {
				Collision collision = Collision(vec3(0,0,0), vec3(0,0,0), 0);
				bool test = SceneIntersections(ray, collision);

				Material mat = GetMaterial(collision.material_index);
				return BRDF(ray, mat, collision.normal);

				return vec3(0,0,0);
			}

			vec3 PathTrace(Ray ray) {
				vec3 mask = vec3(1,1,1);
				vec3 accumulated_color = vec3(0,0,0);

				for (int iteration = 0; iteration < 5; iteration++) {
					Collision collision;
					float distribution = 1.0;

					if (!SceneIntersections(ray, collision))
						return vec3(0,0,0);

					Material collision_material = GetMaterial(collision.material_index);
					mask *= BRDF(ray, collision_material, collision.normal) * distribution;

					if (collision_material.material_type == 2) {
						accumulated_color += (mask * collision_material.color * collision_material.emission_rate);
						break;
					}

					vec3 next_dir = PDF(ray, collision_material, collision.normal);

					if (!(next_dir.x == 0.0 && next_dir.y == 0.0 && next_dir.y == 0.0)) {
						ray = Ray(collision.position + next_dir * 0.01, next_dir);
					}
					else {
						break;
					}
				}

				return accumulated_color;
			}

			void main( void ) {
				//if (time > 0) {
					vec2 position = - 1.0 + 2.0 * gl_FragCoord.xy / vec2(512,512);

					spheres[0] = Sphere(vec3(5.0, -3.5, -2.5), 2.0, 1);
					spheres[1] = Sphere(vec3(8.0, 1.5, -2.5), 2.0, 3);

					materials[0] = Material(vec3(1,0,0), 0, 0.0);
					materials[1] = Material(vec3(0,1,0), 0, 0.0);
					materials[2] = Material(vec3(0,0,1), 0, 0.0);
					materials[3] = Material(vec3(1,1,1), 0, 0.0);
					materials[4] = Material(vec3(1,0,0), 0, 0.0);
					materials[5] = Material(vec3(1,1,1), 2, 10.0);

					camera = InitCamera();
					Ray ray = CreateRay(gl_FragCoord.xy);

					vec3 color = vec3(0,0,0);
					color = PathTrace(ray);

					gl_FragColor = vec4(color, 1.0);
			//	}

			}
		</script>

		<script>
      app();
		</script>

	</body>
</html>
