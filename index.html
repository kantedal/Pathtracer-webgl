<!DOCTYPE HTML>
<html>
	<head>
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
		<title>WebGL Boilerplate</title>

		<style>
			html, body {
				background-color: #fff;
				margin: 0px;
				overflow: hidden;
				width: 100%;
				height: 100%;
			}
			canvas {
				width: 512px;
				height: 512px;
			}
		</style>
	</head>
	<body>
    <!-- <script src="./dist/glMatrix-0.9.5.min.js"> </script> -->
		<script src="./lib/gl-matrix-min.js"></script>
		<script src="./lib/jquery.min.js"></script>
    <script src="./dist/app.js"> </script>

		<canvas></canvas>
		<div id="info"></div>

		<script id="vs_render" type="x-shader/vertex">
			attribute vec3 vertex;
			varying vec2 texCoord;
			void main() {
				texCoord = vertex.xy * 0.5 + 0.5;
				gl_Position = vec4(vertex, 1.0);
			}
		</script>

		<script id="fs_render" type="x-shader/fragment">
			precision highp float;
			uniform float samples;
			varying vec2 texCoord;
			uniform sampler2D texture;
			void main() {
				vec3 color = vec3(texture2D(texture, texCoord)) * 1.0 / samples;

				color = vec3(
					pow(clamp(color.x, 0.0, 1.0), 0.7),
					pow(clamp(color.y, 0.0, 1.0), 0.7),
					pow(clamp(color.z, 0.0, 1.0), 0.7)
				);

				gl_FragColor = vec4(color, 1.0);
			}
		</script>

		<script id="vs" type="x-shader/vertex">
			attribute vec3 vertex;
			varying vec2 texCoord;
			void main() {
		  	texCoord = vertex.xy * 0.5 + 0.5;
				gl_Position = vec4(vertex, 1.0);
			}
		</script>

		<script id="fs" type="x-shader/fragment">
			precision highp float;
			uniform float samples;
			uniform float time;
			uniform vec2 resolution;

			uniform sampler2D u_buffer_texture;
			uniform sampler2D u_triangle_texture;

			float random(vec3 scale, float seed) {
				return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);
			}

			struct Camera {
				vec3 position;
				vec3 v1;
				vec3 v2;
				vec3 v3;
				vec3 v4;
			};
			Camera camera;

			struct Ray {
				vec3 start_position;
				vec3 direction;
			};

			struct Collision {
				vec3 position;
				vec3 normal;
				int material_index;
			};

			struct Material {
				vec3 color;
				int material_type;
				float emission_rate;
			};
			Material materials[9];

			Material GetMaterial(int material_index) {
				for (int i = 0; i < 9; i++) {
					if (i == material_index) {
						return materials[i];
					}
				}
			}

			vec3 BRDF(Ray ray, Material material, vec3 collision_normal, vec3 next_dir) {
				// Lambertian diffuse material
				if (material.material_type == 0) {
					return material.color * dot(ray.direction, -collision_normal);// / 3.14 * 2.0;
				}

				// Specular material
				if (material.material_type == 1) {
					return material.color;
				}

				// Emission material
				if (material.material_type == 2) {
					return material.color;
				}

				// Transmission material
				if (material.material_type == 3) {
					return material.color;
				}

				// Oren nayar diffuse material
				if (material.material_type == 4) {
					float albedo = 1.8;
					float roughness = 1.0;
					vec3 view_direction = -1.0 * ray.direction;

					// set value depending on materia
					const float PI = 3.14159;

					// calculate intermediary values
					float NdotL = dot(collision_normal, next_dir);
					float NdotV = dot(collision_normal, view_direction);

					float angleVN = acos(NdotV);
					float angleLN = acos(NdotL);

					float alpha = max(angleVN, angleLN);
					float beta = min(angleVN, angleLN);
					float gamma = dot(view_direction - collision_normal * dot(view_direction, collision_normal), next_dir - collision_normal * dot(next_dir, collision_normal));

					float roughnessSquared = roughness * roughness;

					// calculate A and B
					float A = 1.0 - 0.5 * (roughnessSquared / (roughnessSquared + 0.57));

					float B = 0.45 * (roughnessSquared / (roughnessSquared + 0.09));

					float C = sin(alpha) * tan(beta);

					// put it all together
					float L1 = max(0.0, NdotL) * (A + B * max(0.0, gamma) * C);

					// get the final color
					return material.color * L1;


					// float LdotV = dot(next_dir, view_direction);
				  // float NdotL = dot(next_dir, collision_normal);
				  // float NdotV = dot(collision_normal, view_direction);
					//
				  // float s = LdotV - NdotL * NdotV;
				  // float t = mix(1.0, max(NdotL, NdotV), step(0.0, s));
					//
				  // float sigma2 = roughness * roughness;
				  // float A = 1.0 + sigma2 * (albedo / (sigma2 + 0.13) + 0.5 / (sigma2 + 0.33));
				  // float B = 0.45 * sigma2 / (sigma2 + 0.09);
					// //
				  // return albedo * max(0.0, NdotL) * (A + B * s / t) / 3.14 * material.color;
				}
			}

			vec3 PDF(Ray ray, Material material, vec3 collision_normal, int iteration, inout float distribution) {
				vec3 real_normal = dot(collision_normal, ray.direction) > 0.0 ? -1.0 * collision_normal : collision_normal;
				vec3 next_dir;

				if (material.material_type == 0 ) {
					float r1 = 2.0 * 3.14 * random(vec3(12.9898, 78.233, 151.7182), time + float(iteration));
	        float r2 = random(vec3(63.7264, 10.873, 623.6736), time + float(iteration));
	        float r2s = sqrt(r2);

	        vec3 w = collision_normal;
	        vec3 u = normalize(cross((abs(w.x) > .1 ? vec3(0, 1, 0) : vec3(1, 0, 0)), w));
	        vec3 v = cross(w, u);

	        // compute cosine weighted random ray direction on hemisphere
	        next_dir = normalize(u * cos(r1) * r2s + v * sin(r1) * r2s + w * sqrt(1.0 - r2));

					return next_dir;
				}

				if (material.material_type == 4) {
					float r1 = 2.0 * 3.14 * random(vec3(12.9898, 78.233, 151.7182), time + float(iteration));
	        float r2 = random(vec3(63.7264, 10.873, 623.6736), time + float(iteration));
	        float r2s = sqrt(r2);

	        vec3 w = collision_normal;
	        vec3 u = normalize(cross((abs(w.x) > .1 ? vec3(0, 1, 0) : vec3(1, 0, 0)), w));
	        vec3 v = cross(w, u);

	        // compute cosine weighted random ray direction on hemisphere
	        next_dir = normalize(u * cos(r1) * r2s + v * sin(r1) * r2s + w * sqrt(1.0 - r2));

					return next_dir;
				}

				if (material.material_type == 1) {
					return normalize(ray.direction - 2.0 * dot(ray.direction, collision_normal) * collision_normal);
				}

				if (material.material_type == 3) {
					bool into = dot(collision_normal, real_normal) > 0.0; // is ray entering or leaving refractive material?
	        float nc = 1.0;  // Index of Refraction air
	        float nt = 1.3;  // Index of Refraction glass/water
	        float nnt = into ? nc / nt : nt / nc;  // IOR ratio of refractive materials
	        float ddn = dot(ray.direction, real_normal);
	        float cos2t = 1.0 - nnt*nnt * (1.0 - ddn*ddn);

	        if (cos2t < 0.0) // total internal reflection
	        {
	            next_dir = normalize(ray.direction - collision_normal * 2.0 * dot(collision_normal, ray.direction));
	        }
	        else // cos2t > 0
	        {
            // compute direction of transmission ray
            vec3 tdir = ray.direction * nnt;
            tdir -= normalize(collision_normal * ((into ? 1.0 : -1.0) * (ddn * nnt + sqrt(cos2t))));

            float R0 = (nt - nc)*(nt - nc) / (nt + nc)*(nt + nc);
            float c = 1.0 - (into ? -ddn : dot(tdir, collision_normal));
            float Re = R0 + (1.0 - R0) * c * c * c * c * c;
            float Tr = 1.0 - Re; // Transmission
            float P = 0.25 + 0.5 * Re;
            float RP = Re / P;
            float TP = Tr / (1.0 - P);

            // randomly choose reflection or transmission ray
						float rand = random(vec3(86.425, 145.233, 42.525), time + float(iteration));
            if (rand < 0.2) // reflection ray
            {
              distribution = RP;
              next_dir = normalize(ray.direction - collision_normal * 2.0 * dot(collision_normal, ray.direction));
            }
            else // transmission ray
            {
              distribution = TP;
              next_dir = normalize(tdir);
            }

						return next_dir;
	        }
				}

				return vec3(0,0,0);
			}


			Camera InitCamera() {
				float field_of_view = 3.14 / 4.0;
        float d = 0.5 / tan(field_of_view / 2.0);
      	vec3 camera_v1 = vec3(0, -1.0/d, -1.0/d);
        vec3 camera_v2 = vec3(0, 1.0/d, -1.0/d);
        vec3 camera_v3 = vec3(0, 1.0/d, 1.0/d);
        vec3 camera_v4 = vec3(0, -1.0/d, 1.0/d);
				vec3 position = vec3(-1,0,0);

				Camera c = Camera(position, camera_v1, camera_v2, camera_v3, camera_v4);
				return c;
			}

			struct Sphere {
				vec3 position;
				float radius;
				int material_index;
			};
			Sphere spheres[3];

			bool SphereIntersection(Ray ray, Sphere sphere, inout Collision collision) {
				vec3 position = sphere.position;
				float radius = sphere.radius;

				vec3 op = position - ray.start_position;
				float t, epsilon = 0.0001;
				float b = dot(op, ray.direction);
				float disc = b * b - dot(op, op) + radius * radius;
				if (disc < 0.0) return false;
				else disc = sqrt(disc);


			  t = (t = b - disc) > epsilon ? t : ((t = b + disc) > epsilon ? t : 0.0);

				if (t < 0.01)
				  return false;

				collision.position = ray.start_position + ray.direction * t;
				collision.normal = normalize(collision.position  - position);
				collision.material_index = sphere.material_index;

				return true;
			}

			struct Triangle {
				vec3 v0;
				vec3 edge1;
				vec3 edge2;
				int material_index;
			};

			Ray CreateRay(vec2 pixel_position, int sample) {
				vec3 base_vector_x = camera.v3 - camera.v4;
				vec3 base_vector_y = camera.v1 - camera.v4;

				float width = 512.0;
				float height = 512.0;

				vec3 dx = (base_vector_x / width);
				vec3 dy = (base_vector_y / height);

				vec3 rand_x = dx * random(vec3(1.9898, 128.13, 7.7182), time + float(sample));
        vec3 rand_y = dy * random(vec3(134.9898, 36.342, 424.232), time + float(sample));

		    vec3 vert = camera.v4 + pixel_position.x / width * base_vector_x + (1.0 - pixel_position.y / height) * base_vector_y;
				vert += rand_x + rand_y;
		    vec3 direction = normalize(vert - camera.position);

				return Ray(camera.position, direction);
			}

			Triangle GetTriangleFromIndex(int triangle_index) {
				// Fetch triangle from texture
				vec2 sample = vec2(1.0,0) / vec2(2048, 2048);
				vec2 start_sample = (vec2(1.0,0) / vec2(2048, 2048)) * float(triangle_index) * 4.0 + 0.5 * sample;

				vec3 v0 = vec3(texture2D(u_triangle_texture, start_sample));
				vec3 v1 = vec3(texture2D(u_triangle_texture, start_sample + sample));
				vec3 v2 = vec3(texture2D(u_triangle_texture, start_sample + 2.0 * sample));

				vec3 edge1 = v1 - v0;
				vec3 edge2 = v2 - v0;

				int material_index = int(texture2D(u_triangle_texture, start_sample + 3.0 * sample).x);

				return Triangle(v0, edge1, edge2, material_index);
			}


			bool TriangleIntersection(Ray ray, Triangle triangle, inout Collision collision) {
				float EPS = 0.0001;

				//Begin calculating determinant - also used to calculate u parameter
				vec3 P = cross(ray.direction, triangle.edge2);
				float det = dot(triangle.edge1, P);

				if (det > -EPS && det < EPS) return false;
				float inv_det = 1.0 / det;

				//Distance from vertex1 to ray origin
				vec3 T = ray.start_position - triangle.v0;
				float u = dot(T, P);
				if (u < 0.0 || u > det) return false;

				vec3 Q = cross(T, triangle.edge1);

				float v = dot(ray.direction, Q);
				if(v < 0.0 || u+v > det) return false;

				float t = dot(triangle.edge2, Q);

				if(t > EPS) {
				    collision.position = ray.start_position + inv_det * t * ray.direction;
				    collision.material_index = triangle.material_index;
				    collision.normal = normalize(cross(triangle.edge1, triangle.edge2));
				    return true;
				}

				return false;
			}

			bool SceneIntersections(Ray ray, inout Collision collision) {
				//Collision collision = Collision(vec3(0,0,0), vec3(0,0,0), 0);

				//Check sphere collision
				for (int sphere_idx = 0; sphere_idx < 3; sphere_idx++) {
					Sphere sphere = spheres[sphere_idx];
					if (SphereIntersection(ray, sphere, collision)) {
						return true;
					}
				}

				// Check triangle collision
				for (int tri_idx = 0; tri_idx < 25; tri_idx++) {
					Triangle triangle = GetTriangleFromIndex(tri_idx);
					if (TriangleIntersection(ray, triangle, collision)) {
						return true;
					}
				}

				// Triangle triangle = GetTriangleFromIndex(0);
				return false;
			}

			vec3 TraceRay(Ray ray) {
				Collision collision = Collision(vec3(0,0,0), vec3(0,0,0), 0);
				bool test = SceneIntersections(ray, collision);

				Material mat = GetMaterial(collision.material_index);
				//return BRDF(ray, mat, collision.normal);

				return vec3(0,0,0);
			}

			vec3 PathTrace(Ray ray) {
				vec3 mask = vec3(1,1,1);
				vec3 accumulated_color = vec3(0,0,0);

				for (int iteration = 0; iteration < 5; iteration++) {
					Collision collision;
					float distribution = 1.0;

					if (!SceneIntersections(ray, collision))
						return vec3(0,0,0);


					Material collision_material = GetMaterial(collision.material_index);
					vec3 next_dir = PDF(ray, collision_material, collision.normal, iteration, distribution);
					mask *= BRDF(ray, collision_material, collision.normal, next_dir) * distribution;

					if (collision_material.material_type == 2) {
						accumulated_color += (mask * collision_material.color * collision_material.emission_rate);
						break;
					}

					if (!(next_dir.x == 0.0 && next_dir.y == 0.0 && next_dir.z == 0.0)) {
						ray = Ray(collision.position + next_dir * 0.01, next_dir);
					}
					else {
						break;
					}
				}

				return accumulated_color;
			}

			void main( void ) {
					spheres[0] = Sphere(vec3(5.0, 0, -3.5), 0.5, 5);
					spheres[1] = Sphere(vec3(9.0, 1.8, -3.0), 1.8, 3);
					spheres[2] = Sphere(vec3(9.0, -1.8, -3.0), 1.8, 8);

					materials[0] = Material(vec3(1,0,0), 0, 0.0);
					materials[1] = Material(vec3(0,1,0), 0, 0.0);
					materials[2] = Material(vec3(0,0,1), 0, 0.0);
					materials[3] = Material(vec3(1,1,1), 0, 0.0);
					materials[4] = Material(vec3(0.5,0.2,0.2), 1, 0.0);
					materials[5] = Material(vec3(1,0.8,0.8), 2, 5.0); // Light
					materials[6] = Material(vec3(0.5,0.9,1.0), 2, 20.0); // Light
					materials[7] = Material(vec3(0.6,1.0,0.6), 3, 0.0); // Transmission
					materials[8] = Material(vec3(1.0,1.0,1.0), 4, 0.0); // Oren nayar

					camera = InitCamera();

					vec3 color = vec3(0,0,0);
					for (int sample = 0; sample < 4; sample++) {
						Ray ray = CreateRay(gl_FragCoord.xy, sample);
						color += PathTrace(ray);
					}
					color /= 4.0;

					vec3 texture = texture2D(u_buffer_texture, gl_FragCoord.xy / 512.0).rgb;

					vec3 new_clr = texture + color; //mix(color, texture, samples / (samples + 1.0));
					gl_FragColor = vec4(new_clr, 1.0);
			}
		</script>

		<script>
      app();
		</script>

	</body>
</html>
